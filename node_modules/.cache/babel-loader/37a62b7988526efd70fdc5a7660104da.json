{"ast":null,"code":"/**\r\n * Alexander Weinberg\r\n * SID: @02876360\r\n */\n\n/**\r\n * Given a Boggle board and a dictionary, returns a list of available words in\r\n * the dictionary present inside of the Boggle board.\r\n * @param {string[][]} grid - The Boggle game board.\r\n * @param {string[]} dictionary - The list of available words.\r\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\r\n */\nexports.findAllSolutions = function (grid, dictionary) {\n  let solutions_Set = new Array();\n  let solutions = [];\n\n  if (grid == null || dictionary == null) {\n    //checks of grid or dict is empty\n    return solutions;\n  }\n\n  for (let i = 0; i < grid.length; i++) {\n    if (grid[i].length != grid.length) {\n      return solutions;\n    }\n  }\n\n  convertToLowerCase(grid, dictionary);\n  let trie = new Set(dictionary);\n\n  for (let y = 0; y < grid.length; y++) {\n    for (let x = 0; x < grid.length; x++) {\n      let visited = new Array(grid.length).fill(false).map(() => new Array(grid.length).fill(false));\n      let word = []; //is empty to start\n\n      findWords(word, grid, trie, x, y, visited, solutions_Set);\n    }\n  }\n\n  solutions = Array.from(solutions_Set);\n  return solutions;\n};\n\nfunction findWords(word, grid, trie, y, x, visited, solutions_Set) {\n  //this is the recursive call\n  const adjacent_lookup = [[-1, -1], [-1, 0], [-1, 1], [0, 1], [1, 1], [1, 0], [1, -1], [0, -1]]; //given a wor and grid[y][x] and visited[y][x]\n  //Base cases:\n  // y/x out of bounds\n  // it already visited grid [y][x] \n\n  if (y < 0 || y >= grid.length || x < 0 || x >= grid.length || visited[y][x] == true) return; //1. append grid [y][x] to the word\n\n  word += grid[y][x]; //word = word + grid\n  //2. check if word is a prefix\n\n  if (isPrefix(trie, word)) {\n    visited[y][x] = true; //2a. check if prefix is marked as visited\n    //2b. test if word is valid\n\n    if (isWord(trie, word)) {\n      //2b. if word is valid: word is added to solution_Set\n      solutions_Set.push(word);\n    } //2c. call findWords, and call each adjacent grid[y][x]\n\n\n    for (let i = 0; i < 8; i++) {\n      findWords(word, grid, trie, y + adjacent_lookup[i][0], x + adjacent_lookup[i][1], visited, solutions_Set); //3. unmark visited[y][x]\n    }\n  }\n\n  visited[y][x] = false;\n} //will return true if prefix is found in the trie\n\n\nfunction isPrefix(trie, word) {\n  //O(N) operation\n  for (let tword of trie) {\n    if (tword.substr(0, word.length) == word) {\n      return true;\n    }\n  }\n\n  return false;\n} //returns true if word is found in the trie\n\n\nfunction isWord(trie, word) {\n  for (let tword of trie) {\n    if (tword == word && word.length >= 3) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction convertToLowerCase(grid, dictionary) {\n  for (let x = 0; x < grid.length; x++) {\n    for (let i = 0; i < grid[x].length; i++) {\n      grid[x][i] = grid[x][i].toLowerCase();\n    }\n  }\n\n  for (let x = 0; x < dictionary.length; x++) {\n    dictionary[x] = dictionary[x].toLowerCase();\n  }\n} // /////////TEST_#1////////\n// var grid1 = [['A', 'B'], ['C', 'D']];\n// var dictionary = ['A', 'B', 'AC', 'ACA', 'ACB', 'DE'];\n// /**\n//  * answer: ['ACB']\n//  */\n// console.log('Test #1: ');\n// console.log(exports.findAllSolutions(grid1, dictionary));\n// // /////////TEST_#2////////\n// var grid2 = [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['A', 'B', 'C', 'D']];\n// var dictionary = ['ABEF', 'AFJIEB', 'DGKD', 'DGKA'];\n// /**\n//  * answer: ['ABEF','AFJIEB','DGKD']\n//  */\n// console.log('Test #2: ');\n// console.log(exports.findAllSolutions(grid2, dictionary));\n// /////////TEST_#3////////\n// var grid3 = [['T', 'W', 'Y', 'R'],\n// ['E', 'N', 'P', 'H'],\n// ['G', 'Z', 'Qu', 'R'],\n// ['O', 'N', 'T', 'A']];\n// var dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat',\n//     'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp',\n//     'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar'];\n// /**\n//  * answer: ['art', 'ego', 'gent', 'get', 'net', 'new','newt', 'prat','pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp','ten', 'went', 'wet', 'quar']\n//  */\n// console.log('Test #3: ');\n// console.log(exports.findAllSolutions(grid3, dictionary));\n// //         /////////TEST_#4////////\n// var grid = [];\n// var dictionary = [];\n// /**\n//  * answer: []\n//  */\n// console.log('Test #4: (empty) ');\n// console.log(exports.findAllSolutions(grid, dictionary));\n// // ///////////////////////////////////////////////////\n// // creats a new Boggle board and calls getSolutions \n// exports.findAllSolutions = function (grid, dictionary) {\n//     return []\n// }\n// var grid = [\n//     [\"T\", \"W\", \"Y\", \"R\"],\n//     [\"E\", \"N\", \"P\", \"H\"],\n//     [\"G\", \"Z\", \"Qu\", \"R\"],\n//     [\"O\", \"N\", \"T\", \"A\"]\n// ];\n// var dictionary = [\"art\", \"ego\", \"gent\", \"get\", \"net\", \"new\", \"newt\", \"prat\", \"pry\", \"qua\", \"quart\", \"quartz\", \"rat\", \"tar\", \"tarp\", \"ten\", \"went\", \"wet\", \"arty\", \"egg\", \"not\", \"quar\"];\n// console.log(exports.findAllSolutions(grid, dictionary));","map":{"version":3,"sources":["/Users/javis/Documents/GitHub/Boggle-Web-App/src/boggle_solver.js"],"names":["exports","findAllSolutions","grid","dictionary","solutions_Set","Array","solutions","i","length","convertToLowerCase","trie","Set","y","x","visited","fill","map","word","findWords","from","adjacent_lookup","isPrefix","isWord","push","tword","substr","toLowerCase"],"mappings":"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","sourcesContent":["/**\r\n * Alexander Weinberg\r\n * SID: @02876360\r\n */\r\n/**\r\n * Given a Boggle board and a dictionary, returns a list of available words in\r\n * the dictionary present inside of the Boggle board.\r\n * @param {string[][]} grid - The Boggle game board.\r\n * @param {string[]} dictionary - The list of available words.\r\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\r\n */\r\nexports.findAllSolutions = function (grid, dictionary) {\r\n    let solutions_Set = new Array();\r\n    let solutions = [];\r\n\r\n    if (grid == null || dictionary == null) { //checks of grid or dict is empty\r\n        return solutions;\r\n    }\r\n\r\n    for (let i = 0; i < grid.length; i++) {\r\n        if (grid[i].length != grid.length) {\r\n            return solutions;\r\n        }\r\n    }\r\n\r\n    convertToLowerCase(grid, dictionary)\r\n    let trie = new Set(dictionary);\r\n\r\n    for (let y = 0; y < grid.length; y++) {\r\n        for (let x = 0; x < grid.length; x++) {\r\n            let visited = new Array(grid.length).fill(false).map(() => new Array(grid.length).fill(false));\r\n            let word = [];//is empty to start\r\n            findWords(word, grid, trie, x, y, visited, solutions_Set);\r\n        }\r\n    }\r\n    solutions = Array.from(solutions_Set);\r\n    return solutions;\r\n}\r\n\r\nfunction findWords(word, grid, trie, y, x, visited, solutions_Set) { //this is the recursive call\r\n    const adjacent_lookup = [[-1, -1],\r\n    [-1, 0],\r\n    [-1, 1],\r\n    [0, 1],\r\n    [1, 1],\r\n    [1, 0],\r\n    [1, -1],\r\n    [0, -1]];\r\n\r\n    //given a wor and grid[y][x] and visited[y][x]\r\n    //Base cases:\r\n    // y/x out of bounds\r\n    // it already visited grid [y][x] \r\n\r\n    if (y < 0 || y >= grid.length || x < 0 || x >= grid.length || visited[y][x] == true)\r\n        return;\r\n\r\n    //1. append grid [y][x] to the word\r\n    word += grid[y][x]; //word = word + grid\r\n\r\n\r\n    //2. check if word is a prefix\r\n    if (isPrefix(trie, word)) {\r\n        visited[y][x] = true;\r\n\r\n        //2a. check if prefix is marked as visited\r\n        //2b. test if word is valid\r\n\r\n        if (isWord(trie, word)) {\r\n            //2b. if word is valid: word is added to solution_Set\r\n            solutions_Set.push(word);\r\n        }\r\n\r\n        //2c. call findWords, and call each adjacent grid[y][x]\r\n        for (let i = 0; i < 8; i++) {\r\n            findWords(word, grid, trie, y + adjacent_lookup[i][0], x + adjacent_lookup[i][1], visited, solutions_Set);\r\n\r\n            //3. unmark visited[y][x]\r\n        }\r\n    }\r\n\r\n    visited[y][x] = false;\r\n\r\n}\r\n\r\n//will return true if prefix is found in the trie\r\nfunction isPrefix(trie, word) { //O(N) operation\r\n\r\n    for (let tword of trie) {\r\n\r\n        if (tword.substr(0, word.length) == word) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n//returns true if word is found in the trie\r\nfunction isWord(trie, word) {\r\n    for (let tword of trie) {\r\n\r\n        if (tword == word && word.length >= 3) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction convertToLowerCase(grid, dictionary) {\r\n    for (let x = 0; x < grid.length; x++) {\r\n        for (let i = 0; i < grid[x].length; i++) {\r\n            grid[x][i] = grid[x][i].toLowerCase();\r\n        }\r\n    }\r\n    for (let x = 0; x < dictionary.length; x++) {\r\n        dictionary[x] = dictionary[x].toLowerCase();\r\n    }\r\n\r\n}\r\n\r\n// /////////TEST_#1////////\r\n\r\n// var grid1 = [['A', 'B'], ['C', 'D']];\r\n// var dictionary = ['A', 'B', 'AC', 'ACA', 'ACB', 'DE'];\r\n\r\n// /**\r\n//  * answer: ['ACB']\r\n//  */\r\n// console.log('Test #1: ');\r\n// console.log(exports.findAllSolutions(grid1, dictionary));\r\n\r\n\r\n\r\n// // /////////TEST_#2////////\r\n\r\n// var grid2 = [['A', 'B', 'C', 'D'], ['E', 'F', 'G', 'H'], ['I', 'J', 'K', 'L'], ['A', 'B', 'C', 'D']];\r\n// var dictionary = ['ABEF', 'AFJIEB', 'DGKD', 'DGKA'];\r\n\r\n// /**\r\n//  * answer: ['ABEF','AFJIEB','DGKD']\r\n//  */\r\n// console.log('Test #2: ');\r\n// console.log(exports.findAllSolutions(grid2, dictionary));\r\n\r\n\r\n\r\n// /////////TEST_#3////////\r\n\r\n// var grid3 = [['T', 'W', 'Y', 'R'],\r\n// ['E', 'N', 'P', 'H'],\r\n// ['G', 'Z', 'Qu', 'R'],\r\n// ['O', 'N', 'T', 'A']];\r\n// var dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat',\r\n//     'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp',\r\n//     'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar'];\r\n\r\n// /**\r\n//  * answer: ['art', 'ego', 'gent', 'get', 'net', 'new','newt', 'prat','pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp','ten', 'went', 'wet', 'quar']\r\n//  */\r\n// console.log('Test #3: ');\r\n// console.log(exports.findAllSolutions(grid3, dictionary));\r\n\r\n\r\n\r\n// //         /////////TEST_#4////////\r\n\r\n// var grid = [];\r\n// var dictionary = [];\r\n\r\n// /**\r\n//  * answer: []\r\n//  */\r\n// console.log('Test #4: (empty) ');\r\n// console.log(exports.findAllSolutions(grid, dictionary));\r\n\r\n\r\n// // ///////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n// // creats a new Boggle board and calls getSolutions \r\n// exports.findAllSolutions = function (grid, dictionary) {\r\n//     return []\r\n// }\r\n\r\n// var grid = [\r\n//     [\"T\", \"W\", \"Y\", \"R\"],\r\n//     [\"E\", \"N\", \"P\", \"H\"],\r\n//     [\"G\", \"Z\", \"Qu\", \"R\"],\r\n//     [\"O\", \"N\", \"T\", \"A\"]\r\n// ];\r\n// var dictionary = [\"art\", \"ego\", \"gent\", \"get\", \"net\", \"new\", \"newt\", \"prat\", \"pry\", \"qua\", \"quart\", \"quartz\", \"rat\", \"tar\", \"tarp\", \"ten\", \"went\", \"wet\", \"arty\", \"egg\", \"not\", \"quar\"];\r\n// console.log(exports.findAllSolutions(grid, dictionary));\r\n\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}